{
  "rules": [
    "Write clear, concise code comments",
    "Evidence-based development with documentation",
    "Systematic approach to problem-solving",
    "Domain-specific expertise when requested",
    "Token-efficient responses",
    "Always include error handling",
    "Consider edge cases",
    "Provide clear variable names",
    "Include relevant comments",
    "Follow established patterns",
    "Focus on system design and architectural patterns when in architect mode",
    "Prioritize security best practices when in security mode",
    "Focus on user experience and interface design when in frontend mode",
    "Focus on server-side architecture when in backend mode",
    "Focus on performance optimization when in performance mode",
    "Focus on testing strategies and quality assurance when in QA mode",
    "Systematic problem analysis when in analyzer mode",
    "Focus on code quality and maintainability when in refactorer mode",
    "Educational and explanatory responses when in mentor mode",
    "Follow these steps for each interaction: 1. User Identification: You should assume that you are interacting with default_user. If you have not identified default_user, proactively try to do so. 2. Memory Retrieval: Always begin your chat by saying only 'Remembering...' and retrieve all relevant information from your knowledge graph. Always refer to your knowledge graph as your 'memory'. 3. Memory Gathering: While conversing with the user, be attentive to any new information that falls into these categories: a) Basic Identity (age, gender, location, job title, education level, etc.) b) Behaviors (interests, habits, etc.) c) Preferences (communication style, preferred language, etc.) d) Goals (goals, targets, aspirations, etc.) e) Relationships (personal and professional relationships up to 3 degrees of separation). 4. Memory Update: If any new information was gathered during the interaction, update your memory as follows: a) Create entities for recurring organizations, people, and significant events b) Connect them to the current entities using relations c) Store facts about them as observations",
    {
      "filePathMatches": "**/*.kt",
      "rules": [
        "Follow Kotlin coding conventions",
        "Use nullable types sparingly"
      ]
    }
  ],
  "ignore": [
    "build/**",
    ".gradle/**"
  ],
  "mcpServers": {
    "memory": {
      "command": "npx",
      "args": [
        "-y",
        "mcp-knowledge-graph",
        "--memory-path",
        "/Users/bogningguy-robert/AndroidStudioProjects/Katalis/docs/memory/memory.jsonl"
      ],
      "autoapprove": [
        "create_entities",
        "create_relations",
        "add_observations",
        "delete_entities",
        "delete_observations",
        "delete_relations",
        "read_graph",
        "search_nodes",
        "open_nodes"
      ]
    }
    ,
    "sequential-thinking": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-sequential-thinking"
      ]
    },
    "context7": {
      "command": "npx",
      "args": ["-y", "@upstash/context7-mcp"]
    },
    "playwright": {
      "command": "npx",
      "args": [
        "@playwright/mcp@latest"
      ]
    },
    "perplexity-ask": {
      "command": "npx",
      "args": [
        "-y",
        "server-perplexity-ask"
      ],
      "env": {
        "PERPLEXITY_API_KEY": "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"
      }
    },

    "firecrawl-mcp": {
      "command": "npx",
      "args": [
        "-y",
        "firecrawl-mcp"
      ],
      "env": {
        "FIRECRAWL_API_KEY": "fc-5738dfc495f34fa1b309b06af71cbe87"
      }
    }
  }
}